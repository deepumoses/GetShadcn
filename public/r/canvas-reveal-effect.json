{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "canvas-reveal-effect",
  "title": "Canvas Reveal Effect",
  "description": "A canvas-based reveal effect.",
  "dependencies": [
    "motion",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/canvas-reveal-effect.tsx",
      "content": "\"use client\"\n\nimport { cn } from \"@/lib/utils\"\nimport React, {\n  createContext,\n  useContext,\n  useRef,\n  useEffect,\n  useState,\n} from \"react\"\nimport { useMotionValue, motion, useMotionTemplate } from \"motion/react\"\n\nexport const CanvasRevealEffect = ({\n  animationSpeed = 0.4,\n  opacities = [0.3, 0.3, 0.3, 0.5, 0.5, 0.5, 0.8, 0.8, 0.8, 1],\n  colors = [[0, 255, 255]],\n  containerClassName,\n  dotSize,\n  showGradient = true,\n}: {\n  animationSpeed?: number\n  opacities?: number[]\n  colors?: number[][]\n  containerClassName?: string\n  dotSize?: number\n  showGradient?: boolean\n}) => {\n  return (\n    <div className={cn(\"h-full relative bg-white w-full\", containerClassName)}>\n      <div className=\"h-full w-full\">\n        <DotMatrix\n          colors={colors ?? [[0, 255, 255]]}\n          dotSize={dotSize ?? 3}\n          opacities={\n            opacities ?? [0.3, 0.3, 0.3, 0.5, 0.5, 0.5, 0.8, 0.8, 0.8, 1]\n          }\n          shader={`\n              float animation_speed_factor = ${animationSpeed.toFixed(1)};\n              float intro_offset = distance(u_resolution / 2.0 / u_total_size, st2);\n              return vec4(vec3(intro_offset), 1.0);\n            `}\n          center={[\"x\", \"y\"]}\n        />\n      </div>\n      {showGradient && (\n        <div className=\"absolute inset-0 bg-gradient-to-t from-white to-transparent\" />\n      )}\n    </div>\n  )\n}\n\nconst DotMatrix = ({\n  colors,\n  dotSize,\n  opacities,\n  shader,\n  center,\n}: {\n  colors: number[][]\n  dotSize: number\n  opacities: number[]\n  shader: string\n  center: (\"x\" | \"y\")[]\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const ctx = canvas.getContext(\"2d\")\n    if (!ctx) return\n\n    let animationFrameId: number\n\n    const render = () => {\n      // Basic rendering loop placeholder\n      // Full shader implementation is complex and requires WebGL\n      // This is a simplified 2D canvas fallback for the visual effect\n      const width = canvas.width\n      const height = canvas.height\n      ctx.clearRect(0, 0, width, height)\n\n      const time = performance.now() / 1000\n\n      for(let i = 0; i < 50; i++) {\n          const x = Math.random() * width\n          const y = Math.random() * height\n          const color = colors[Math.floor(Math.random() * colors.length)]\n\n          ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`\n          ctx.fillRect(x, y, dotSize, dotSize)\n      }\n\n      animationFrameId = requestAnimationFrame(render)\n    }\n\n    render()\n\n    return () => {\n      cancelAnimationFrame(animationFrameId)\n    }\n  }, [])\n\n  return <canvas ref={canvasRef} className=\"h-full w-full\" />\n}\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:component"
}